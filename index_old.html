<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Agent Chess AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: #333;
            min-height: 100vh;
            padding: 15px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 500px 1fr;
            grid-template-rows: auto 1fr;
            gap: 20px;
            height: calc(100vh - 30px);
        }

        .header {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 2.2em;
        }

        .model-selection {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .model-card {
            background: #3498db;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 600;
        }

        .model-card:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .model-card.selected {
            background: #e74c3c;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #27ae60;
            color: white;
        }

        .btn-primary:hover {
            background: #229954;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .chess-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-info {
            text-align: center;
            margin-bottom: 15px;
            width: 100%;
        }

        .status {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .move-history {
            max-height: 60px;
            overflow-y: auto;
            background: #ecf0f1;
            padding: 8px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.85em;
            width: 100%;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 45px);
            grid-template-rows: repeat(8, 45px);
            border: 3px solid #2c3e50;
            border-radius: 8px;
            overflow: hidden;
            margin: 15px 0;
        }

        .chess-square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chess-square.light {
            background: #f0d9b5;
        }

        .chess-square.dark {
            background: #b58863;
        }

        .chess-square:hover {
            background: #ffeb3b !important;
        }

        .chess-square.selected {
            background: #4caf50 !important;
        }

        .analysis-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .analysis-panel h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
        }

        .common-prompt-section {
            background: #e8f5e8;
            border: 2px solid #27ae60;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .common-prompt-title {
            color: #27ae60;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .common-prompt-text {
            background: white;
            border-radius: 6px;
            padding: 12px;
            font-size: 0.85em;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.4;
            border: 1px solid #27ae60;
        }

        .stockfish-section {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .stockfish-title {
            color: #e65100;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stockfish-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 0.9em;
        }

        .stockfish-item {
            background: white;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #ffcc02;
        }

        .stockfish-label {
            font-weight: bold;
            color: #e65100;
            font-size: 0.8em;
        }

        .models-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .individual-model-box {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .model-box-header {
            background: #3498db;
            color: white;
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .model-name {
            font-weight: bold;
            font-size: 1em;
        }

        .model-status {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }

        .model-box-content {
            padding: 15px;
        }

        .move-suggestion {
            background: #27ae60;
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-block;
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 0.95em;
        }

        .move-suggestion.no-move {
            background: #e74c3c;
        }

        .confidence-section {
            margin: 10px 0;
        }

        .confidence-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-bottom: 4px;
        }

        .reasoning-text {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 12px;
            margin-top: 8px;
            font-size: 0.85em;
            line-height: 1.4;
            color: #34495e;
            max-height: 200px;
            overflow-y: auto;
        }

        .thinking-time {
            font-size: 0.75em;
            color: #7f8c8d;
            margin-top: 8px;
            text-align: right;
        }

        .confidence-bar {
            background: #ecf0f1;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin-top: 4px;
        }

        .confidence-fill {
            background: linear-gradient(to right, #e74c3c, #f39c12, #27ae60);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .consensus-section {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .consensus-move {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .consensus-strength {
            font-size: 0.9em;
            margin-bottom: 12px;
        }

        .debate-section {
            background: #fff4e6;
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .debate-title {
            color: #e65100;
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .conflict-indicator {
            background: #ff5722;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.75em;
        }

        .debate-rounds {
            background: white;
            border-radius: 6px;
            padding: 12px;
            margin-top: 10px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }

        .spinner {
            border: 3px solid #ecf0f1;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto 8px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 450px 1fr;
            }
        }

        @media (max-width: 1000px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto 1fr;
            }
            
            .chess-section {
                order: 2;
            }

            .analysis-panel {
                order: 3;
            }
        }

        @media (max-width: 768px) {
            .chess-board {
                grid-template-columns: repeat(8, 35px);
                grid-template-rows: repeat(8, 35px);
            }
            
            .chess-square {
                font-size: 1.4em;
            }
            
            .header h1 {
                font-size: 1.8em;
            }

            .stockfish-content {
                grid-template-columns: 1fr;
            }

            .common-prompt-text {
                max-height: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Multi-Agent Chess AI</h1>
            <div class="model-selection" id="modelSelection">
                <!-- Model cards will be populated here -->
            </div>
            <div class="controls">
                <button class="btn btn-primary" id="analyzeBtn" onclick="analyzePosition()">Analyze Position</button>
                <button class="btn btn-secondary" id="stockfishBtn" onclick="playStockfishMove()">Stockfish Move</button>
                <button class="btn btn-secondary" onclick="resetGame()">New Game</button>
            </div>
        </div>

        <div class="chess-section">
            <div class="game-info">
                <div class="status" id="gameStatus">White to move</div>
                <div class="move-history" id="moveHistory">Game started</div>
            </div>
            <div class="chess-board" id="chessBoard">
                <!-- Chess board squares will be populated here -->
            </div>
        </div>

        <div class="analysis-panel">
            <h3>ü§ñ AI Model Analysis</h3>
            
            <div id="analysisContent">
                <div class="loading">
                    Select models and click "Analyze Position" to see AI reasoning
                </div>
            </div>
        </div>
    </div>

    <script>
        class ChessGame {
            constructor() {
                this.currentFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
                this.selectedModels = [];
                this.gameHistory = [];
                this.selectedSquare = null;
                this.isAnalyzing = false;
                this.websocket = null;
                this.currentAnalysis = {
                    stockfish_eval: null,
                    model_responses: [],
                    debate_rounds: [],
                    phase: 'idle'
                };
                
                // NEW: Persistent storage for all analyses and moves
                this.analysisHistory = []; // Stores all previous analyses
                this.moveCounter = 0; // Track move numbers
                
                this.init();
            }

            async init() {
                await this.loadModels();
                this.renderBoard();
                this.updateGameStatus();
                this.connectWebSocket();
                // Always get Stockfish evaluation for the current position
                await this.updateStockfishEvaluation();
            }

            async updateStockfishEvaluation() {
                try {
                    const response = await fetch('/api/stockfish_eval');
                    if (response.ok) {
                        this.currentAnalysis.stockfish_eval = await response.json();
                        await this.updateAnalysisDisplay();
                    }
                } catch (error) {
                    console.error('Error updating Stockfish evaluation:', error);
                }
            }

            connectWebSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                this.websocket = new WebSocket(wsUrl);
                
                this.websocket.onopen = () => {
                    console.log('WebSocket connected');
                };
                
                this.websocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    this.handleWebSocketMessage(data);
                };
                
                this.websocket.onclose = () => {
                    console.log('WebSocket disconnected, attempting to reconnect...');
                    setTimeout(() => this.connectWebSocket(), 3000);
                };
                
                this.websocket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }

            handleWebSocketMessage(data) {
                console.log('WebSocket message:', data);
                
                switch (data.type) {
                    case 'analysis_start':
                        this.currentAnalysis = {
                            stockfish_eval: null,
                            model_responses: [],
                            debate_rounds: [],
                            phase: 'starting'
                        };
                        this.updateAnalysisDisplay();
                        break;
                        
                    case 'stockfish_complete':
                        this.currentAnalysis.stockfish_eval = data.stockfish_evaluation;
                        this.updateAnalysisDisplay();
                        break;
                        
                    case 'phase_start':
                        this.currentAnalysis.phase = data.phase;
                        this.updateAnalysisDisplay();
                        break;
                        
                    case 'model_start':
                        this.showModelProgress(data);
                        break;
                        
                    case 'model_complete':
                        this.addModelResponse(data);
                        this.updateAnalysisDisplay();
                        break;
                        
                    case 'conflict_detected':
                        this.currentAnalysis.phase = 'conflict';
                        this.updateAnalysisDisplay();
                        break;
                        
                    case 'analysis_complete':
                        this.currentAnalysis.phase = 'complete';
                        this.currentAnalysis.final_result = data.final_result;
                        this.updateAnalysisDisplay();
                        break;
                }
            }

            addModelResponse(data) {
                // Add or update model response
                const existingIndex = this.currentAnalysis.model_responses.findIndex(
                    r => r.model_name === data.model_name && r.phase === data.phase
                );
                
                const responseData = {
                    ...data.response,
                    phase: data.phase,
                    model_index: data.model_index
                };
                
                if (existingIndex >= 0) {
                    this.currentAnalysis.model_responses[existingIndex] = responseData;
                } else {
                    this.currentAnalysis.model_responses.push(responseData);
                }
            }

            showModelProgress(data) {
                // Show that a model is currently working
                document.getElementById('analysisContent').innerHTML += `
                    <div id="progress-${data.model_name}-${data.phase}" class="loading">
                        <div class="spinner"></div>
                        ${data.message}
                    </div>
                `;
            }

            async loadModels() {
                try {
                    const response = await fetch('/api/models');
                    const data = await response.json();
                    this.renderModelSelection(data.models);
                } catch (error) {
                    console.error('Error loading models:', error);
                }
            }

            renderModelSelection(models) {
                const container = document.getElementById('modelSelection');
                container.innerHTML = '';

                models.forEach(model => {
                    const card = document.createElement('button');
                    card.className = 'model-card';
                    card.textContent = this.getModelDisplayName(model);
                    card.onclick = () => this.toggleModel(model, card);
                    container.appendChild(card);
                });
            }

            getModelDisplayName(model) {
                const names = {
                    'llama3.2:1b': 'Llama 3.2 1B',
                    'llama3.2:3b': 'Llama 3.2 3B',
                    'qwen2.5:1.5b': 'Qwen 2.5 1.5B',
                    'gemma2:2b': 'Gemma 2 2B'
                };
                return names[model] || model;
            }

            toggleModel(model, card) {
                if (this.selectedModels.includes(model)) {
                    this.selectedModels = this.selectedModels.filter(m => m !== model);
                    card.classList.remove('selected');
                } else {
                    this.selectedModels.push(model);
                    card.classList.add('selected');
                }
            }

            renderBoard() {
                const board = document.getElementById('chessBoard');
                board.innerHTML = '';

                const pieces = this.fenToPieces(this.currentFen);

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.square = this.indexToSquare(row, col);
                        
                        const piece = pieces[row][col];
                        if (piece) {
                            square.textContent = this.pieceToUnicode(piece);
                        }

                        square.onclick = () => this.onSquareClick(row, col);
                        board.appendChild(square);
                    }
                }
            }

            fenToPieces(fen) {
                const board = Array(8).fill().map(() => Array(8).fill(null));
                const position = fen.split(' ')[0];
                const rows = position.split('/');

                for (let row = 0; row < 8; row++) {
                    let col = 0;
                    for (let char of rows[row]) {
                        if (isNaN(char)) {
                            board[row][col] = char;
                            col++;
                        } else {
                            col += parseInt(char);
                        }
                    }
                }

                return board;
            }

            pieceToUnicode(piece) {
                const pieces = {
                    'K': '\u2654', 'Q': '\u2655', 'R': '\u2656', 'B': '\u2657', 'N': '\u2658', 'P': '\u2659',
                    'k': '\u265A', 'q': '\u265B', 'r': '\u265C', 'b': '\u265D', 'n': '\u265E', 'p': '\u265F'
                };
                return pieces[piece] || '';
            }

            indexToSquare(row, col) {
                return String.fromCharCode(97 + col) + (8 - row);
            }

            onSquareClick(row, col) {
                const square = document.querySelector(`[data-square="${this.indexToSquare(row, col)}"]`);
                
                if (this.selectedSquare) {
                    const fromSquare = this.selectedSquare;
                    const toSquare = this.indexToSquare(row, col);
                    
                    // Clear selection
                    document.querySelectorAll('.chess-square').forEach(s => {
                        s.classList.remove('selected');
                    });
                    this.selectedSquare = null;
                    
                    // Try to make move
                    if (fromSquare !== toSquare) {
                        this.makeMove(`${fromSquare}${toSquare}`);
                    }
                } else {
                    // Select square
                    document.querySelectorAll('.chess-square').forEach(s => {
                        s.classList.remove('selected');
                    });
                    square.classList.add('selected');
                    this.selectedSquare = this.indexToSquare(row, col);
                }
            }

            async makeMove(move) {
                try {
                    const response = await fetch('/api/play_move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ move: move })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        this.currentFen = data.fen;
                        this.gameHistory = data.history;
                        this.renderBoard();
                        this.updateGameStatus();
                        
                        // Always update Stockfish evaluation for new position
                        await this.updateStockfishEvaluation();
                        
                        if (data.game_over) {
                            alert(data.result);
                        }
                    } else {
                        const error = await response.json();
                        alert(`Invalid move: ${error.detail}`);
                    }
                } catch (error) {
                    console.error('Error making move:', error);
                    alert('Error making move. Please try again.');
                }
            }

            updateGameStatus() {
                const statusEl = document.getElementById('gameStatus');
                const historyEl = document.getElementById('moveHistory');
                
                const isWhiteToMove = this.currentFen.includes(' w ');
                statusEl.textContent = `${isWhiteToMove ? 'White' : 'Black'} to move`;
                
                historyEl.textContent = this.gameHistory.length > 0 
                    ? this.gameHistory.join(' ') 
                    : 'Game started';
            }

            async analyzePosition() {
                if (this.selectedModels.length === 0) {
                    alert('Please select at least one model for analysis');
                    return;
                }

                if (this.isAnalyzing) return;
                this.isAnalyzing = true;

                const analyzeBtn = document.getElementById('analyzeBtn');
                const stockfishBtn = document.getElementById('stockfishBtn');
                
                analyzeBtn.disabled = true;
                stockfishBtn.disabled = true;
                analyzeBtn.textContent = 'Analyzing...';

                // Reset analysis state
                this.currentAnalysis = {
                    stockfish_eval: null,
                    model_responses: [],
                    debate_rounds: [],
                    phase: 'starting'
                };

                try {
                    // Step 1: Show initial setup
                    this.currentAnalysis.phase = 'starting';
                    await this.updateAnalysisDisplay();

                    // Step 2: Get Stockfish evaluation
                    this.currentAnalysis.phase = 'stockfish_loading';
                    await this.updateAnalysisDisplay();
                    
                    const stockfishResponse = await fetch('/api/stockfish_eval');
                    if (stockfishResponse.ok) {
                        this.currentAnalysis.stockfish_eval = await stockfishResponse.json();
                    }

                    // Step 3: Independent model analysis - call each model individually
                    this.currentAnalysis.phase = 'independent_analysis';
                    await this.updateAnalysisDisplay();

                    const independentResponses = [];
                    for (let i = 0; i < this.selectedModels.length; i++) {
                        const modelName = this.selectedModels[i];
                        
                        // Update UI to show which model is currently working
                        this.currentAnalysis.phase = `analyzing_${modelName}`;
                        await this.updateAnalysisDisplay();

                        try {
                            const response = await fetch('/api/analyze_model', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    fen: this.currentFen,
                                    model_name: modelName,
                                    previous_reasoning: ""
                                })
                            });

                            if (response.ok) {
                                const modelResponse = await response.json();
                                modelResponse.phase = 'independent';
                                modelResponse.model_index = i;
                                independentResponses.push(modelResponse);
                                this.currentAnalysis.model_responses.push(modelResponse);
                                
                                // Update UI immediately after each model responds
                                await this.updateAnalysisDisplay();
                            }
                        } catch (error) {
                            console.error(`Error analyzing with ${modelName}:`, error);
                        }
                    }

                    // Step 4: Intelligent debate decision based on vote distribution
                    const moveVotes = this.calculateMoveVotes(independentResponses);
                    const debateDecision = this.shouldEnterDebate(moveVotes, this.selectedModels.length);

                    if (debateDecision.needsDebate) {
                        // Show debate reasoning to user
                        this.currentAnalysis.phase = 'debate_reasoning';
                        this.currentAnalysis.debate_reasoning = debateDecision;
                        await this.updateAnalysisDisplay();
                        
                        // Wait a moment for user to read the reasoning
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        this.currentAnalysis.phase = 'conflict_detected';
                        await this.updateAnalysisDisplay();

                        // Prepare debate prompt
                        let debatePrompt = "CONFLICTING MOVE SUGGESTIONS DETECTED:\n";
                        for (const move in moveVotes.moves) {
                            const supportingModels = moveVotes.moves[move].models;
                            debatePrompt += `- ${move}: supported by ${supportingModels.join(', ')}\n`;
                        }

                        // Add other models' reasoning
                        debatePrompt += "\nOTHER MODELS' REASONING:\n";
                        for (const response of independentResponses) {
                            debatePrompt += `--- ${response.model_name} ---\n`;
                            debatePrompt += `Move: ${response.suggested_move}\nReasoning: ${response.reasoning}\n\n`;
                        }
                        
                        debatePrompt += "Given these conflicting views, reconsider your analysis and provide your final recommendation.";

                        // Run debate phase - call each model individually again
                        this.currentAnalysis.phase = 'debate';
                        await this.updateAnalysisDisplay();

                        for (let i = 0; i < this.selectedModels.length; i++) {
                            const modelName = this.selectedModels[i];
                            
                            // Show which model is debating
                            this.currentAnalysis.phase = `debating_${modelName}`;
                            await this.updateAnalysisDisplay();

                            try {
                                const response = await fetch('/api/analyze_model', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        fen: this.currentFen,
                                        model_name: modelName,
                                        previous_reasoning: debatePrompt
                                    })
                                });

                                if (response.ok) {
                                    const debateResponse = await response.json();
                                    debateResponse.phase = 'debate';
                                    debateResponse.model_index = i;
                                    this.currentAnalysis.model_responses.push(debateResponse);
                                    
                                    // Update UI immediately after each debate response
                                    await this.updateAnalysisDisplay();
                                }
                            } catch (error) {
                                console.error(`Error getting debate response from ${modelName}:`, error);
                            }
                        }
                    }

                    // Step 5: Calculate and show final consensus
                    this.currentAnalysis.phase = 'calculating_consensus';
                    await this.updateAnalysisDisplay();

                    let finalResponses, hadDebate;
                    
                    if (debateDecision.needsDebate) {
                        // Use debate responses
                        finalResponses = this.currentAnalysis.model_responses.filter(r => r.phase === 'debate');
                        hadDebate = true;
                    } else {
                        // Use independent responses, winner already decided
                        finalResponses = this.currentAnalysis.model_responses.filter(r => r.phase === 'independent');
                        hadDebate = false;
                    }

                    const consensus = debateDecision.needsDebate ? 
                        this.calculateConsensus(finalResponses) : 
                        { final_move: debateDecision.winner, consensus_strength: 100 };
                    
                    this.currentAnalysis.final_result = {
                        final_move: consensus.final_move,
                        consensus_strength: consensus.consensus_strength,
                        had_conflict: moveVotes.moves && Object.keys(moveVotes.moves).length > 1,
                        had_debate: hadDebate,
                        debate_decision: debateDecision
                    };

                    this.currentAnalysis.phase = 'complete';
                    await this.updateAnalysisDisplay();
                    
                    // Save this analysis to history before it gets overwritten
                    this.saveAnalysisToHistory();

                } catch (error) {
                    console.error('Error analyzing position:', error);
                    document.getElementById('analysisContent').innerHTML = `<div class="loading">Analysis failed: ${error.message}</div>`;
                } finally {
                    this.isAnalyzing = false;
                    analyzeBtn.disabled = false;
                    stockfishBtn.disabled = false;
                    analyzeBtn.textContent = 'Analyze Position';
                }
            }

            calculateMoveVotes(responses) {
                const moveVotes = {};
                let totalModels = 0;
                
                for (const response of responses) {
                    if (response.suggested_move) {
                        if (!moveVotes[response.suggested_move]) {
                            moveVotes[response.suggested_move] = {
                                count: 0,
                                models: [],
                                totalConfidence: 0
                            };
                        }
                        moveVotes[response.suggested_move].count++;
                        moveVotes[response.suggested_move].models.push(response.model_name);
                        moveVotes[response.suggested_move].totalConfidence += response.confidence;
                        totalModels++;
                    }
                }
                
                // Calculate percentages
                for (const move in moveVotes) {
                    moveVotes[move].percentage = (moveVotes[move].count / totalModels) * 100;
                }
                
                return { moves: moveVotes, totalModels };
            }

            shouldEnterDebate(moveVotes, totalModels) {
                const moves = Object.entries(moveVotes.moves);
                
                if (moves.length <= 1) {
                    return { 
                        needsDebate: false, 
                        reason: "All models agree on the same move",
                        winner: moves[0]?.[0] || null
                    };
                }
                
                // Sort by vote count (descending)
                moves.sort((a, b) => b[1].count - a[1].count);
                
                const topMove = moves[0];
                const secondMove = moves[1] || null;
                
                const topPercentage = topMove[1].percentage;
                
                // Clear majority (60%+ for 3+ models, 75%+ for 2 models)
                const majorityThreshold = totalModels === 2 ? 75 : 60;
                
                if (topPercentage >= majorityThreshold) {
                    return {
                        needsDebate: false,
                        reason: `Clear majority: ${topMove[1].count}/${totalModels} models (${topPercentage.toFixed(1)}%) choose ${topMove[0]}`,
                        winner: topMove[0],
                        breakdown: `${topMove[0]}: ${topMove[1].models.join(', ')}`
                    };
                }
                
                // Check for tie (only triggers debate if it's a close tie)
                if (secondMove && topMove[1].count === secondMove[1].count) {
                    return {
                        needsDebate: true,
                        reason: `Tie detected: ${topMove[1].count} models each for ${topMove[0]} and ${secondMove[0]}`,
                        breakdown: `${topMove[0]}: ${topMove[1].models.join(', ')}\n${secondMove[0]}: ${secondMove[1].models.join(', ')}`
                    };
                }
                
                // Close vote but no clear majority
                return {
                    needsDebate: true,
                    reason: `No clear majority: ${topMove[1].count}/${totalModels} models (${topPercentage.toFixed(1)}%) choose ${topMove[0]}`,
                    breakdown: moves.map(([move, data]) => `${move}: ${data.models.join(', ')}`).join('\n')
                };
            }

            calculateConsensus(responses) {
                const moveScores = {};
                let totalConfidence = 0;

                for (const response of responses) {
                    if (response.suggested_move) {
                        moveScores[response.suggested_move] = (moveScores[response.suggested_move] || 0) + response.confidence;
                        totalConfidence += response.confidence;
                    }
                }

                if (Object.keys(moveScores).length === 0) {
                    return { final_move: null, consensus_strength: 0 };
                }

                const bestMove = Object.entries(moveScores).reduce((a, b) => a[1] > b[1] ? a : b);
                const consensusStrength = totalConfidence > 0 ? (bestMove[1] / totalConfidence) * 100 : 0;

                return {
                    final_move: bestMove[0],
                    consensus_strength: consensusStrength
                };
            }

            saveAnalysisToHistory() {
                if (this.currentAnalysis.final_result && this.currentAnalysis.final_result.final_move) {
                    this.moveCounter++;
                    const analysisSnapshot = {
                        moveNumber: this.moveCounter,
                        position: this.currentFen,
                        timestamp: new Date().toLocaleTimeString(),
                        selectedMove: this.currentAnalysis.final_result.final_move,
                        consensusStrength: this.currentAnalysis.final_result.consensus_strength,
                        hadDebate: this.currentAnalysis.final_result.had_debate,
                        stockfish_eval: JSON.parse(JSON.stringify(this.currentAnalysis.stockfish_eval)),
                        model_responses: JSON.parse(JSON.stringify(this.currentAnalysis.model_responses)),
                        debate_decision: this.currentAnalysis.final_result.debate_decision
                    };
                    
                    this.analysisHistory.push(analysisSnapshot);
                    console.log(`Saved analysis #${this.moveCounter} to history`, analysisSnapshot);
                }
            }

            async updateAnalysisDisplay() {
                let html = '';

                // Common prompt section
                const commonPrompt = await this.generateCommonPrompt();
                html += `
                    <div class="common-prompt-section">
                        <div class="common-prompt-title">
                            üìù Common Prompt Given to All Models
                        </div>
                        <div class="common-prompt-text">${commonPrompt}</div>
                    </div>
                `;

                // Phase indicator
                let phaseMessage = '';
                if (this.currentAnalysis.phase.startsWith('analyzing_')) {
                    const modelName = this.currentAnalysis.phase.replace('analyzing_', '');
                    phaseMessage = `ü§ñ Analyzing with ${modelName}...`;
                } else if (this.currentAnalysis.phase.startsWith('debating_')) {
                    const modelName = this.currentAnalysis.phase.replace('debating_', '');
                    phaseMessage = `üó£Ô∏è Getting debate response from ${modelName}...`;
                } else {
                    switch (this.currentAnalysis.phase) {
                        case 'starting': phaseMessage = 'üöÄ Starting analysis...'; break;
                        case 'stockfish_loading': phaseMessage = 'üèÜ Getting Stockfish evaluation...'; break;
                        case 'independent_analysis': phaseMessage = 'ü§ñ Phase 1: Independent Analysis'; break;
                        case 'debate_reasoning': phaseMessage = 'ü§î Analyzing vote distribution...'; break;
                        case 'conflict_detected': phaseMessage = '‚ö° Starting debate phase...'; break;
                        case 'debate': phaseMessage = 'üó£Ô∏è Phase 2: Model Debate'; break;
                        case 'calculating_consensus': phaseMessage = 'üßÆ Calculating consensus...'; break;
                        case 'complete': phaseMessage = '‚úÖ Analysis Complete'; break;
                        default: phaseMessage = ''; break;
                    }
                }

                if (phaseMessage) {
                    html += `
                        <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 12px; margin-bottom: 15px; text-align: center; font-weight: bold; color: #2c3e50;">
                            ${phaseMessage}
                        </div>
                    `;
                }

                // Debate reasoning section  
                if (this.currentAnalysis.debate_reasoning) {
                    const reasoning = this.currentAnalysis.debate_reasoning;
                    const bgColor = reasoning.needsDebate ? '#fff4e6' : '#e8f5e8';
                    const borderColor = reasoning.needsDebate ? '#ff9800' : '#27ae60';
                    const icon = reasoning.needsDebate ? '‚ö°' : '‚úÖ';
                    
                    html += `
                        <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                            <div style="color: ${borderColor}; font-weight: bold; margin-bottom: 10px;">
                                ${icon} Decision: ${reasoning.needsDebate ? 'Debate Required' : 'No Debate Needed'}
                            </div>
                            <div style="font-size: 0.9em; margin-bottom: 8px;">
                                <strong>Reason:</strong> ${reasoning.reason}
                            </div>
                            ${reasoning.breakdown ? `
                                <div style="font-size: 0.85em; background: white; padding: 8px; border-radius: 6px; font-family: monospace;">
                                    ${reasoning.breakdown.replace(/\n/g, '<br>')}
                                </div>
                            ` : ''}
                            ${!reasoning.needsDebate && reasoning.winner ? `
                                <div style="margin-top: 10px; text-align: center;">
                                    <div style="background: ${borderColor}; color: white; padding: 8px 15px; border-radius: 20px; display: inline-block; font-weight: bold;">
                                        Selected Move: ${reasoning.winner}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }

                // Stockfish evaluation section
                if (this.currentAnalysis.stockfish_eval) {
                    const stockfishEval = this.currentAnalysis.stockfish_eval;
                    html += `
                        <div class="stockfish-section">
                            <div class="stockfish-title">
                                üèÜ Stockfish Analysis
                            </div>
                            <div class="stockfish-content">
                                <div class="stockfish-item">
                                    <div class="stockfish-label">Evaluation</div>
                                    <div>${stockfishEval.score || 'Unknown'}</div>
                                </div>
                                <div class="stockfish-item">
                                    <div class="stockfish-label">Best Move</div>
                                    <div>${stockfishEval.best_move_san || 'None'}</div>
                                </div>
                                <div class="stockfish-item">
                                    <div class="stockfish-label">Depth</div>
                                    <div>${stockfishEval.depth || 0}</div>
                                </div>
                                <div class="stockfish-item">
                                    <div class="stockfish-label">Principal Variation</div>
                                    <div>${stockfishEval.pv_san ? stockfishEval.pv_san.join(' ') : 'None'}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Consensus section (only show when complete)
                if (this.currentAnalysis.phase === 'complete' && this.currentAnalysis.final_result) {
                    const result = this.currentAnalysis.final_result;
                    const consensusColor = result.consensus_strength > 70 ? '#27ae60' : 
                                         result.consensus_strength > 50 ? '#f39c12' : '#e74c3c';
                    html += `
                        <div class="consensus-section" style="background: ${consensusColor};">
                            <div class="consensus-move">üéØ Final Move: ${result.final_move}</div>
                            <div class="consensus-strength">Consensus Strength: ${result.consensus_strength.toFixed(1)}%</div>
                            ${this.currentAnalysis.stockfish_eval && this.currentAnalysis.stockfish_eval.best_move_san ? 
                                `<div style="font-size: 0.85em; margin-top: 8px; opacity: 0.9;">
                                    Stockfish best: ${this.currentAnalysis.stockfish_eval.best_move_san}
                                    ${result.final_move === this.currentAnalysis.stockfish_eval.best_move_san ? ' ‚úÖ MATCH!' : ' ‚ùå DIFFERS'}
                                </div>` : ''
                            }
                            <button class="btn btn-primary" onclick="game.makeMove('${result.final_move}')" 
                                    style="background: rgba(255,255,255,0.2); border: 2px solid white; margin-top: 10px;">
                                ‚ñ∂Ô∏è Play This Move
                            </button>
                        </div>
                    `;
                }

                // Individual model boxes - group by phase
                const independentResponses = this.currentAnalysis.model_responses.filter(r => r.phase === 'independent');
                const debateResponses = this.currentAnalysis.model_responses.filter(r => r.phase === 'debate');

                html += '<div class="models-container">';

                // Analysis History Section
                if (this.analysisHistory.length > 0) {
                    html += `<h4 style="color: #8e44ad; margin: 15px 0 10px 0;">üìö Previous Analyses (${this.analysisHistory.length}):</h4>`;
                    html += '<div style="max-height: 200px; overflow-y: auto; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 8px; padding: 10px; background: #f8f9fa;">';
                    
                    // Show last 5 analyses in reverse order (newest first)
                    const recentAnalyses = this.analysisHistory.slice(-5).reverse();
                    recentAnalyses.forEach((analysis, index) => {
                        const isLatest = index === 0;
                        html += `
                            <div style="margin-bottom: 10px; padding: 8px; background: ${isLatest ? '#e8f5e8' : 'white'}; border-radius: 6px; border-left: 4px solid ${isLatest ? '#27ae60' : '#8e44ad'};">
                                <div style="font-size: 0.85em; color: #666; margin-bottom: 4px;">
                                    Move ${analysis.moveNumber} - ${analysis.timestamp} ${isLatest ? '(Latest)' : ''}
                                </div>
                                <div style="font-weight: bold; margin-bottom: 4px;">
                                    üéØ ${analysis.selectedMove} (${analysis.consensusStrength.toFixed(1)}% consensus)
                                    ${analysis.hadDebate ? ' ‚ö° After Debate' : ' ‚úÖ No Debate'}
                                </div>
                                <div style="font-size: 0.8em; color: #666;">
                                    Stockfish: ${analysis.stockfish_eval ? analysis.stockfish_eval.score : 'N/A'}
                                </div>
                            </div>
                        `;
                    });
                    
                    if (this.analysisHistory.length > 5) {
                        html += `<div style="text-align: center; color: #666; font-size: 0.8em; margin-top: 8px;">... and ${this.analysisHistory.length - 5} more analyses</div>`;
                    }
                    
                    html += '</div>';
                }

                // Current Analysis Heading
                if (independentResponses.length > 0 || debateResponses.length > 0) {
                    html += `<h4 style="color: #2c3e50; margin: 15px 0 10px 0;">üîÑ Current Analysis:</h4>`;
                }

                // Independent analysis responses
                if (independentResponses.length > 0) {
                    html += `<h5 style="color: #3498db; margin: 10px 0 8px 0;">ü§ñ Independent Analysis:</h5>`;
                    independentResponses.forEach((response, index) => {
                        html += this.renderModelBox(response, index, 'independent');
                    });
                }

                // Debate responses
                if (debateResponses.length > 0) {
                    html += `<h5 style="color: #e67e22; margin: 15px 0 8px 0;">üó£Ô∏è Debate Responses:</h5>`;
                    debateResponses.forEach((response, index) => {
                        html += this.renderModelBox(response, index, 'debate');
                    });
                }

                html += '</div>';

                document.getElementById('analysisContent').innerHTML = html;
            }

            renderModelBox(response, index, phase) {
                const confidenceWidth = (response.confidence / 10) * 100;
                const modelColor = this.getModelColor(index);
                const phaseIcon = phase === 'debate' ? 'üó£Ô∏è' : 'ü§ñ';
                
                return `
                    <div class="individual-model-box">
                        <div class="model-box-header" style="background: ${modelColor};">
                            <div class="model-name">${phaseIcon} ${response.model_name}</div>
                            <div class="model-status">${phase === 'debate' ? 'Debate' : 'Analysis'}</div>
                        </div>
                        <div class="model-box-content">
                            ${response.suggested_move ? 
                                `<div class="move-suggestion">üí° ${response.suggested_move}</div>` : 
                                `<div class="move-suggestion no-move">‚ùå No Valid Move</div>`
                            }
                            
                            <div class="confidence-section">
                                <div class="confidence-label">Confidence: ${response.confidence}/10</div>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" style="width: ${confidenceWidth}%"></div>
                                </div>
                            </div>
                            
                            <div class="reasoning-text">${response.reasoning}</div>
                            <div class="thinking-time">‚è±Ô∏è ${response.thinking_time.toFixed(2)}s</div>
                        </div>
                    </div>
                `;
            }

            // Legacy function for non-WebSocket analysis
            renderAnalysis(data) {
                // Convert to new format and display
                this.currentAnalysis = {
                    stockfish_eval: data.stockfish_evaluation,
                    model_responses: data.model_responses.map((r, i) => ({ ...r, phase: 'independent', model_index: i })),
                    debate_rounds: data.debate_rounds || [],
                    phase: 'complete',
                    final_result: data
                };
                this.updateAnalysisDisplay();
            }

            getModelColor(index) {
                const colors = ['#3498db', '#9b59b6', '#e67e22', '#1abc9c', '#e74c3c', '#f39c12'];
                return colors[index % colors.length];
            }

            async generateCommonPrompt() {
                const isWhiteToMove = this.currentFen.includes(' w ');
                
                // Get legal moves from backend
                let legalMoves = [];
                try {
                    const response = await fetch('/api/legal_moves', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ fen: this.currentFen })
                    });
                    if (response.ok) {
                        const data = await response.json();
                        legalMoves = data.moves || [];
                    }
                } catch (error) {
                    console.error('Error fetching legal moves:', error);
                }

                const movesString = legalMoves.length > 0 ? legalMoves.join(', ') : 'Error loading moves';
                
                return `You are analyzing a chess position for ${isWhiteToMove ? 'White' : 'Black'}.

üèÅ POSITION: ${this.currentFen}
‚ôüÔ∏è TURN: ${isWhiteToMove ? 'White' : 'Black'} to move

üö® CRITICAL: You MUST select exactly ONE move from the legal moves below.

‚úÖ LEGAL MOVES (choose ONE): ${movesString}

üìã INSTRUCTIONS:
1. Analyze the position thoroughly
2. Consider tactical and positional factors  
3. Evaluate candidate moves
4. You MUST choose one move - failure to select is unacceptable
5. Rate your confidence (1-10)

‚ö° REQUIRED FORMAT:
ANALYSIS: [Your detailed analysis]
MOVE: <move>EXACT_MOVE_HERE</move>
CONFIDENCE: [1-10]

üéØ EXAMPLES:
- MOVE: <move>e4</move> (if e4 is in legal moves)
- MOVE: <move>Nf3</move> (if Nf3 is in legal moves)  
- MOVE: <move>O-O</move> (if O-O is in legal moves)
- MOVE: <move>Qxd7+</move> (if Qxd7+ is in legal moves)

üî• CRITICAL: You MUST use <move> tags around your move or it will NOT be detected!

‚ö†Ô∏è FAILURE TO USE <move> TAGS IS UNACCEPTABLE - Choose from: ${movesString}`;
            }


            async playStockfishMove() {
                try {
                    const response = await fetch('/api/stockfish_move', { method: 'POST' });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.move) {
                            await this.makeMove(data.move);
                        } else {
                            alert('Stockfish could not find a move');
                        }
                    }
                } catch (error) {
                    console.error('Error getting Stockfish move:', error);
                }
            }

            async resetGame() {
                try {
                    const response = await fetch('/api/reset_game', { method: 'POST' });
                    if (response.ok) {
                        const data = await response.json();
                        this.currentFen = data.fen;
                        this.gameHistory = [];
                        
                        // Reset current analysis but KEEP analysis history
                        this.currentAnalysis = {
                            stockfish_eval: null,
                            model_responses: [],
                            debate_rounds: [],
                            phase: 'idle'
                        };
                        
                        this.renderBoard();
                        this.updateGameStatus();
                        
                        // Get Stockfish evaluation for the starting position
                        await this.updateStockfishEvaluation();
                        
                        // Update display to show history + new position
                        await this.updateAnalysisDisplay();
                    }
                } catch (error) {
                    console.error('Error resetting game:', error);
                }
            }
        }

        // Global game instance
        let game;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            game = new ChessGame();
        });

        // Global functions for button clicks
        function analyzePosition() {
            game.analyzePosition();
        }

        function playStockfishMove() {
            game.playStockfishMove();
        }

        function resetGame() {
            game.resetGame();
        }
    </script>
</body>
</html>